<!--
This code has been generated by ChatGPT 3.5.
Almost nothing has been changed by me, a human.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Image Processor</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <style>
        body {
            cursor: default;
        }

        .card,
        img,
        button,
        .btn,
        input[type="file"],
        input[type="checkbox"],
        table {
            border-radius: 0; /* Supprime les bords arrondis pour ces éléments */
        }
    </style>
</head>
<body>

<!-- Section 1: Image Upload -->
<div class="container mt-3">
    <div class="card bg-light">
        <div class="card-body">
            <div class="container">
                <h3 class="mb-4">Image processor</h3>
                <div class="mb-3">
                    <input type="file" class="form-control" id="imageUpload">
                </div>
            </div>

            <!-- Section 2: Lego Colors Selection -->
            <div class="container mt-3">
                <h3>Select Lego colors</h3>
                <div class="mb-2">
                    <label>
                        <button id="checkAll" class="btn btn-primary"> Check All</button>
                    </label>
                    <label>
                        <button id="uncheckAll" class="btn btn-primary"> Uncheck All</button>
                    </label>
                </div>
                <div id="legoColorsCheckboxes">
                    <table class="w-100">
                        <tbody id="checkboxRow">
                        <tr></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="container mt-4">
                <button id="processImageButton" class="btn btn-success w-100" onclick="processImage()">
                    <span id="processImageText">Process image</span>
                    <div class="spinner-border spinner-border-sm ms-2" role="status" id="processingSpinner" style="display: none;">
                        <span class="visually-hidden">Processing...</span>
                    </div>
                    <span class="ms-2" id="completionPercentage" style="display: none;">0%</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Images Display Section -->
<div class="container-fluid mt-3 d-none" id="imageDisplaySection">
    <div class="row">
        <div class="col-md-6">
            <div class="card bg-light mb-3">
                <div class="card-body">
                    <table class="table table-primary" style="table-layout: fixed;">
                        <tbody>
                        <tr>
                            <td class="text-center">
                                <p class="mb-0">Original image</p>
                            </td>
                            <td class="text-center">
                                <p id="imageDimensions" class="mb-0"></p>
                            </td>
                            <td class="text-center">
                                <p id="imageSize" class="mb-0"></p>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <img id="originalImage" class="img-fluid mx-auto d-block" alt="Original Image">
                </div>
            </div>
        </div>
        <div class="col-md-6" id="processedImageSection">
            <div class="card bg-light mb-3">
                <div class="card-body">
                    <table class="table table-primary" style="table-layout: fixed;">
                        <tbody>
                        <tr>
                            <td class="text-center">
                                <p class="mb-0">Processed image</p>
                            </td>
                            <td class="text-center">
                                <p id="processsedImageDimensions" class="mb-0"></p>
                            </td>
                            <td class="text-center">
                                <p id="processsedImageLegosCount" class="mb-0"></p>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <img id="processedImage" class="img-fluid mx-auto d-block" alt="Processed Image">
                    <button class="btn btn-success w-100 mt-3" onclick="generateZip()">Download</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Bootstrap JS and dependencies -->
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>

<!-- Your JavaScript for Image Processing -->
<script src="lego-colors.js"></script>
<script>
    // Dynamically generate checkboxes for Lego colors in a table
    const checkboxRow = document.getElementById('checkboxRow');
    let cellCounter = 0;

    for (const color in legoColors) {
        if (cellCounter === 6) {
            cellCounter = 0;
            checkboxRow.appendChild(document.createElement('tr'));
        }

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = color;
        checkbox.id = color;
        checkbox.checked = true; // Default to checked
        checkbox.style.marginLeft = '5px';
        checkbox.style.marginRight = '3px';

        // Ajouter le span pour le nombre de pixels
        const pixelCountSpan = document.createElement('span');
        pixelCountSpan.className = 'pixel-count';

        const label = document.createElement('label');
        label.htmlFor = color;
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(legoColors[color].name));
        label.appendChild(pixelCountSpan);
        label.style.backgroundColor = '#' + color;
        label.style.width = '100%';
        label.style.color = legoColors[color].textColor;

        const cell = document.createElement('td');
        cell.appendChild(label);

        checkboxRow.lastElementChild.appendChild(cell);

        cellCounter++;
    }

    // Ajouter des écouteurs d'événements à chaque case à cocher
    const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');

    // Gérer le clic sur la case à cocher "Check All"
    document.getElementById('checkAll').addEventListener('click', function () {
        const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');
        for (const checkbox of checkboxes) {
            checkbox.checked = true;
        }
    });

    // Gérer le clic sur la case à cocher "Uncheck All"
    document.getElementById('uncheckAll').addEventListener('click', function () {
        const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');
        for (const checkbox of checkboxes) {
            checkbox.checked = false;
        }
    });

    // Récupérez l'élément d'entrée de fichier
    const imageUpload = document.getElementById('imageUpload');

    // Attachez un événement au changement de l'entrée de fichier pour cocher toutes les cases
    imageUpload.addEventListener('change', function() {
        checkAllCheckboxes();
        updateImageDimensions();
        updateImageSize();
        updateImageAndTable();
        document.getElementById('imageDisplaySection').classList.remove('d-none');
        document.getElementById('processedImageSection').classList.add('d-none');
    });

    function processImage() {
        // Afficher le spinner et masquer le texte du bouton
        document.getElementById('processingSpinner').style.display = 'inline-block';
        document.getElementById('processImageText').style.display = 'none';
        document.getElementById('processedImageSection').classList.add('d-none');

        // Afficher le pourcentage de complétion et masquer le texte du bouton
        const completionPercentage = document.getElementById('completionPercentage');
        completionPercentage.style.display = 'inline-block';
        completionPercentage.innerText = '0%';

        const imageUpload = document.getElementById('imageUpload');
        const originalImage = document.getElementById('originalImage');
        const processedImage = document.getElementById('processedImage');
        const imageDisplaySection = document.getElementById('imageDisplaySection');

        // Get selected Lego colors
        const selectedColors = Array.from(legoColorsCheckboxes.getElementsByTagName('input'))
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);

        // Check if an image is selected
        if (imageUpload.files.length > 0) {
            const reader = new FileReader();

            // Read the selected image
            reader.onload = function (e) {
                const img = new Image();
                img.src = e.target.result;

                img.onload = function () {
                    // Display original image
                    originalImage.src = img.src;

                    // Process the image and display the processed image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    // Créez un worker
                    const worker = new Worker('imageProcessWorker.js');

                    // Envoyez les données nécessaires au worker
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    const selectedColors = Array.from(legoColorsCheckboxes.getElementsByTagName('input'))
                        .filter(checkbox => checkbox.checked)
                        .map(checkbox => checkbox.value);

                    worker.postMessage({
                        imageData: imageData,
                        selectedColors: selectedColors
                    });

                    // Gérez la réponse du worker
                    worker.onmessage = function(e) {
                        if (e.data.percentage !== undefined) {
                            // Mettez à jour le pourcentage de complétion
                            completionPercentage.innerText = e.data.percentage.toFixed(0) + '%';
                        } else {
                            // Use the processed image data directly
                            const processedImageData = e.data.processedImageData;
                            ctx.putImageData(processedImageData, 0, 0);
                            processedImage.src = canvas.toDataURL('image/png');

                            // Show the image display section
                            imageDisplaySection.classList.remove('d-none');
                            document.getElementById('processedImageSection').classList.remove('d-none');

                            // Store the used colors in an array
                            const usedColors = [];

                            const pixels = imageData.data;

                            for (let i = 0; i < pixels.length; i += 4) {
                                const closestColor = findClosestColor(pixels[i], pixels[i + 1], pixels[i + 2], selectedColors);
                                // Ajouter la couleur la plus proche utilisée à la liste
                                const usedColor = rgbToHex(closestColor.red, closestColor.green, closestColor.blue);
                                if (!usedColors.includes(usedColor)) {
                                    usedColors.push(usedColor);
                                }
                            }

                            updateCheckboxes(usedColors, imageData);

                            // Afficher le nombre de pixels de la couleur du background dans le label
                            const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');
                            for (const checkbox of checkboxes) {
                                const color = checkbox.value;
                                const label = checkbox.parentElement; // Récupérer l'élément parent, c'est-à-dire le label

                                if (usedColors.includes(color)) {
                                    const pixelCount = countPixels(imageData, hexToRgb(color)).toLocaleString('en-EN');
                                    label.lastElementChild.innerText = ` (${pixelCount})`;
                                } else {
                                    label.lastElementChild.innerText = '';
                                }
                            }

                            updateProcessedImageDimensions();
                            updateProcessedImageLegosCount();

                            // Cacher le spinner et afficher le texte du bouton après le traitement de l'image
                            document.getElementById('processingSpinner').style.display = 'none';
                            document.getElementById('processImageText').style.display = 'inline-block';
                            completionPercentage.style.display = 'none';
                        }
                    }
                };
            };

            reader.readAsDataURL(imageUpload.files[0]);
        } else {
            alert('Please select an image.');
        }
    }

    function findClosestColor(red, green, blue, selectedColors) {
        let closestColor = { distance: Infinity };

        for (const color of selectedColors) {
            const [targetRed, targetGreen, targetBlue] = hexToRgb(color);

            const distance = Math.sqrt(
                Math.pow(targetRed - red, 2) +
                Math.pow(targetGreen - green, 2) +
                Math.pow(targetBlue - blue, 2)
            );

            if (distance < closestColor.distance) {
                closestColor = {
                    distance: distance,
                    red: targetRed,
                    green: targetGreen,
                    blue: targetBlue,
                };
            }
        }

        return closestColor;
    }

    function hexToRgb(hex) {
        hex = hex.replace(/^#/, '');
        const bigint = parseInt(hex, 16);
        const red = (bigint >> 16) & 255;
        const green = (bigint >> 8) & 255;
        const blue = bigint & 255;
        return [red, green, blue];
    }

    function rgbToHex(red, green, blue) {
        // Convertir les valeurs RGB en hexadécimal
        const hex = (red << 16 | green << 8 | blue).toString(16);
        // Remplir de zéros à gauche si nécessaire
        const paddedHex = '000000'.slice(0, 6 - hex.length) + hex;
        // Convertir en majuscules et retourner la chaîne hexadécimale
        return paddedHex.toUpperCase();
    }

    function updateCheckboxes(usedColors, imageData) {
        const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');

        for (const checkbox of checkboxes) {
            checkbox.checked = usedColors.includes(checkbox.value);
            checkbox.dataset.pixelCount = countPixels(imageData, hexToRgb(checkbox.value));
        }
    }

    // Ajouter une fonction pour compter le nombre de pixels d'une couleur spécifique dans l'image
    function countPixels(imageData, targetColor) {
        const pixels = imageData.data;
        let count = 0;

        for (let i = 0; i < pixels.length; i += 4) {
            const pixelColor = [pixels[i], pixels[i + 1], pixels[i + 2]];

            if (pixelColor.every((value, index) => value === targetColor[index])) {
                count++;
            }
        }

        return count;
    }

    // Ajoutez une fonction pour cocher toutes les cases
    function checkAllCheckboxes() {
        const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');
        for (const checkbox of checkboxes) {
            checkbox.checked = true;
        }
    }

    // Ajoutez cette fonction pour calculer les dimensions de l'image
    function updateImageDimensions() {
        const imageUpload = document.getElementById('imageUpload');
        const imageDimensionsElement = document.getElementById('imageDimensions');

        if (imageUpload.files.length > 0) {
            const reader = new FileReader();

            reader.onload = function (e) {
                const img = new Image();
                img.src = e.target.result;

                img.onload = function () {
                    const dimensions = `Dimensions: ${img.width} x ${img.height} pixels`;
                    imageDimensionsElement.innerText = dimensions;
                };
            };

            reader.readAsDataURL(imageUpload.files[0]);
        } else {
            // Réinitialisez le texte si aucun fichier n'est sélectionné
            imageDimensionsElement.innerText = '';
        }
    }

    // Ajoutez cette fonction pour mettre à jour la taille de l'image en KB ou MB
    function updateImageSize() {
        const imageUpload = document.getElementById('imageUpload');
        const imageSizeElement = document.getElementById('imageSize');

        if (imageUpload.files.length > 0) {
            const fileSizeInKB = imageUpload.files[0].size / 1024;
            let fileSize;

            if (fileSizeInKB < 1024) {
                fileSize = fileSizeInKB.toFixed(2) + ' KB';
            } else {
                fileSize = (fileSizeInKB / 1024).toFixed(2) + ' MB';
            }

            // Ajoutez "Size: " devant la taille de l'image
            imageSizeElement.innerText = 'Size: ' + fileSize;
        } else {
            // Réinitialisez le texte si aucun fichier n'est sélectionné
            imageSizeElement.innerText = '';
        }
    }

    function updateProcessedImageDimensions() {
        const processedImage = document.getElementById('processedImage');
        const processedImageDimensionsElement = document.getElementById('processsedImageDimensions');

        if (processedImage.src) {
            if (processedImage.complete) {
                // Calculer et afficher la largeur et la hauteur de l'image générée
                let processedImageWidth = processedImage.naturalWidth * 0.8; // Convertir de pixels à cm
                let processedImageWidthUnit = 'cm';
                if (processedImageWidth > 100) {
                    processedImageWidth = processedImageWidth / 100;
                    processedImageWidthUnit = 'm';
                }

                let processedImageHeight = processedImage.naturalHeight * 0.8; // Convertir de pixels à cm
                let processedImageHeightUnit = 'm';
                if (processedImageHeight > 100) {
                    processedImageHeight = processedImageHeight / 100;
                    processedImageHeightUnit = 'm';
                }

                const dimensions = `Dimensions: ${processedImageWidth.toFixed(2)}${processedImageWidthUnit} x ${processedImageHeight.toFixed(2)}${processedImageHeightUnit}`;
                processedImageDimensionsElement.innerText = dimensions;
            } else {
                setTimeout(function () {
                    updateProcessedImageDimensions();
                }, 100);
            }
        } else {
            // Réinitialisez le texte si aucune image n'a été générée
            processedImageDimensionsElement.innerText = '';
        }
    }

    function updateProcessedImageLegosCount() {
        const processedImage = document.getElementById('processedImage');
        const processedImageLegosCountElement = document.getElementById('processsedImageLegosCount');

        if (processedImage.src) {
            if (processedImage.complete) {
                // Obtenez les dimensions de l'image traitée
                const width = processedImage.naturalWidth;
                const height = processedImage.naturalHeight;

                // Calculez le nombre total de pixels dans l'image
                const totalPixels = (width * height).toLocaleString('en-EN');

                // Mettez à jour le nombre total de pixels dans le texte
                const legosCountText = `Legos 1x1: ${totalPixels}`;
                processedImageLegosCountElement.innerText = legosCountText;
            } else {
                setTimeout(function () {
                    updateProcessedImageLegosCount();
                }, 100);
            }
        } else {
            // Réinitialisez le texte si aucune image n'a été générée
            processedImageLegosCountElement.innerText = '';
        }
    }

    function updateImageAndTable() {
        const imageUpload = document.getElementById('imageUpload');
        const originalImage = document.getElementById('originalImage');

        // Lire l'image sélectionnée
        if (imageUpload.files.length > 0) {
            const reader = new FileReader();

            reader.onload = function (e) {
                const img = new Image();
                img.src = e.target.result;

                img.onload = function () {
                    // Afficher l'image originale
                    originalImage.src = img.src;

                    // Mettez à jour les dimensions de l'image et la taille
                    updateImageDimensions();
                    updateImageSize();
                };
            };

            reader.readAsDataURL(imageUpload.files[0]);
        } else {
            // Réinitialisez l'image et le tableau si aucun fichier n'est sélectionné
            originalImage.src = '';
            imageDimensionsElement.innerText = '';
            imageSizeElement.innerText = '';
        }
    }

    function generateCSV() {
        const checkboxes = legoColorsCheckboxes.getElementsByTagName('input');
        const selectedColors = Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => ({
                color: checkbox.value,
                name: legoColors[checkbox.value].name,
                pixelCount: checkbox.dataset.pixelCount || 0, // Récupérez le nombre de pixels du dataset
            }));

        // Créez le contenu CSV
        let csvContent = 'Color name,Color code,Legos 1x1\n';
        selectedColors.forEach(color => {
            csvContent += `${color.name},${color.color},${color.pixelCount}\n`;
        });

        return csvContent;
    }

    function generateZip() {
        // Créez une instance JSZip
        const zip = new JSZip();

        zip.file('legos_1x1.csv', generateCSV());

        // Ajoutez l'image générée au zip
        const processedImage = document.getElementById('processedImage');
        const imageDataURL = processedImage.src;
        const imageData = imageDataURL.split(',')[1]; // Ignore the data:image/png;base64, part
        zip.file('image.png', imageData, { base64: true });

        // Générez le contenu du zip
        zip.generateAsync({ type: 'blob' }).then(function (blob) {
            // Créez un lien pour télécharger le fichier zip
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'ImageToLego.zip';
            link.click();
        });
    }
</script>

</body>
</html>
